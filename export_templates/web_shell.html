<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<meta name="theme-color" content="#1a1a2e">
		<title>$GODOT_PROJECT_NAME</title>
		<style>
			* {
				margin: 0;
				padding: 0;
				box-sizing: border-box;
			}
			html, body {
				width: 100%;
				height: 100%;
				overflow: hidden;
				background-color: #1a1a2e;
			}
			#canvas-container {
				width: 100%;
				height: 100%;
				overflow: hidden;
				display: flex;
				align-items: center;
				justify-content: center;
			}
			#canvas {
				display: block;
				width: 100%;
				height: 100%;
				touch-action: none;
				transform-origin: center center;
			}
			#status {
				position: absolute;
				left: 50%;
				top: 50%;
				transform: translate(-50%, -50%);
				text-align: center;
				color: #ffffff;
				font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
			}
			#status-progress {
				width: 300px;
				height: 8px;
				background-color: #333;
				border-radius: 4px;
				margin: 20px auto;
				overflow: hidden;
			}
			#status-progress-inner {
				width: 0%;
				height: 100%;
				background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
				border-radius: 4px;
				transition: width 0.3s ease;
			}
			#status-notice {
				margin-top: 10px;
				font-size: 14px;
				opacity: 0.7;
			}
		</style>
		<script src="coi-serviceworker.min.js"></script>
		$GODOT_HEAD_INCLUDE
	</head>
	<body>
		<div id="canvas-container">
			<canvas id="canvas"></canvas>
		</div>
		<div id="status">
			<div id="status-progress">
				<div id="status-progress-inner"></div>
			</div>
			<div id="status-notice">Loading...</div>
		</div>
		<script src="index.js"></script>
		<script>
			const GODOT_CONFIG = $GODOT_CONFIG;
			const engine = new Engine(GODOT_CONFIG);

			const statusProgress = document.getElementById('status-progress-inner');
			const statusNotice = document.getElementById('status-notice');
			const status = document.getElementById('status');

			function setStatusMode(mode) {
				if (mode === 'hidden') {
					status.style.display = 'none';
				} else {
					status.style.display = 'block';
				}
			}

			function setStatusNotice(text) {
				statusNotice.textContent = text;
			}

			function displayFailureNotice(err) {
				setStatusNotice('Error: ' + (err.message || err));
				console.error(err);
			}

			engine.startGame({
				'onProgress': function (current, total) {
					if (total > 0) {
						const percent = (current / total) * 100;
						statusProgress.style.width = percent + '%';
						setStatusNotice('Loading... ' + Math.round(percent) + '%');
					} else {
						setStatusNotice('Loading...');
					}
				},
			}).then(() => {
				setStatusMode('hidden');
				initZoom();
			}).catch((err) => {
				displayFailureNotice(err);
			});

			// Zoom functionality
			function initZoom() {
				const canvas = document.getElementById('canvas');
				const container = document.getElementById('canvas-container');

				let scale = 1;
				let translateX = 0;
				let translateY = 0;
				const minScale = 0.5;
				const maxScale = 5;

				function updateTransform() {
					canvas.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale})`;
				}

				// Desktop: Ctrl + mouse wheel zoom
				container.addEventListener('wheel', function(e) {
					if (e.ctrlKey) {
						e.preventDefault();

						const rect = container.getBoundingClientRect();
						const mouseX = e.clientX - rect.left - rect.width / 2;
						const mouseY = e.clientY - rect.top - rect.height / 2;

						const delta = e.deltaY > 0 ? 0.9 : 1.1;
						const newScale = Math.min(maxScale, Math.max(minScale, scale * delta));

						if (newScale !== scale) {
							const scaleChange = newScale / scale;
							translateX = mouseX - (mouseX - translateX) * scaleChange;
							translateY = mouseY - (mouseY - translateY) * scaleChange;
							scale = newScale;
							updateTransform();
						}
					}
				}, { passive: false });

				// Mobile: Pinch to zoom
				let initialDistance = 0;
				let initialScale = 1;
				let initialTranslateX = 0;
				let initialTranslateY = 0;
				let initialMidpoint = { x: 0, y: 0 };

				container.addEventListener('touchstart', function(e) {
					if (e.touches.length === 2) {
						e.preventDefault();
						const touch1 = e.touches[0];
						const touch2 = e.touches[1];
						initialDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY);
						initialScale = scale;
						initialTranslateX = translateX;
						initialTranslateY = translateY;

						const rect = container.getBoundingClientRect();
						initialMidpoint = {
							x: (touch1.clientX + touch2.clientX) / 2 - rect.left - rect.width / 2,
							y: (touch1.clientY + touch2.clientY) / 2 - rect.top - rect.height / 2
						};
					}
				}, { passive: false });

				container.addEventListener('touchmove', function(e) {
					if (e.touches.length === 2) {
						e.preventDefault();
						const touch1 = e.touches[0];
						const touch2 = e.touches[1];
						const currentDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY);

						const newScale = Math.min(maxScale, Math.max(minScale, initialScale * (currentDistance / initialDistance)));

						if (newScale !== scale) {
							const scaleChange = newScale / initialScale;
							translateX = initialMidpoint.x - (initialMidpoint.x - initialTranslateX) * scaleChange;
							translateY = initialMidpoint.y - (initialMidpoint.y - initialTranslateY) * scaleChange;
							scale = newScale;
							updateTransform();
						}
					}
				}, { passive: false });

				// Double-tap to reset zoom
				let lastTap = 0;
				container.addEventListener('touchend', function(e) {
					const now = Date.now();
					if (now - lastTap < 300 && e.touches.length === 0) {
						scale = 1;
						translateX = 0;
						translateY = 0;
						updateTransform();
					}
					lastTap = now;
				});
			}
		</script>
	</body>
</html>
